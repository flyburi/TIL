# 5장 제네릭
## 아이템 26. raw 타입은 사용하지 말라

용어정리.
List<String>은 원소의 타입인 String인 리스트를 뜻하는 매개변수화 타입이다.
여기서 String이 정규(formal) 타입 매개변수 E에 해당하는 실제(actual) 타입 매개변수다.

raw type이란 제네릭 타입에서 타입 매개변수를 전혀 사용하지 않을 때를 말한다.
예컨대 List<E>의 raw 타입은 List다. 
raw 타입은 타입 선언에서 제네릭 타입 정보가 전부 지워진 것처럼 동작하는데, 제네릭이 도래하기 전 코드와 호환되도록 하기 위한 궁여지책이라 할 수 있다.

코드 26-1 컬렉션의 raw 타입 - 따라 하지 말것!
```
// Stamp 인스턴스만 취급한다.
private final Collection stamps= ..;
```

코드 26-3 매개변수화된 컬렉션 타입 - 타입 안전성 확보
```
private final Collection<Stamp> stamps= ..;
```
이렇게 선언하면 컴파일러는 stamps에는 Stamp의 인스턴스만 넣어야함을 컴파일러가 인식한다.


raw 타입을 쓰면 제네릭이 안겨주는 안전성과 표현력을 모두 잃게 된다.
raw 타입은 제네릭없이 짠 코드가 있어서 하위 호환성때문에 만들어 놓은것.

List 같은 raw 타입은 사용해서는 안되나, List<Object>처럼 임의 객체를 허용하는 매개변수화 타입은 괜찮다.
raw 타입인 List와 List<Object>의 차이는 무엇일까?
List는 제네릭 타입에서 완전히 발을 뺀 것이고, List<Object>는 모든 타입을 허용한다는 의사를 컴파일러에 명확히 전달한 것이다.
매개변수로 List를 받는 메서드에 List<String>을 넘길 수 있지만, List<Object>를 받는 메서드에는 넘길 수 없다. 
이는 제네릭의 하위 타입 규칙 때문. 즉, List<String>은 raw 타입인 List의 하위 타입이지만, List<Object>의 하위 타입은 아니다.
그 결과 List<Object>와 같은 매개변수화 타입을 사용할 때와 달리 List같은 raw 타입을 사용하면 타입 안전성을 잃게 된다.

원소의 타입을 몰라도 되는 raw 타입을 쓰고 싶다면?
비한정적 와일드카드 타입(unbounede wildcard type)을 대신 사용하는 게 좋다.
제네릭 타입을 쓰고 싶지만 실제 타입 매개변수가 무엇인지 신경 쓰고 싶지 않다면 물음표(?)를 사용하자.

Set<?>와 raw 타입인 Set의 차이는 무엇일까?
와일드카드 탕입은 안전하고, raw 타입은 안전하지 않다.
raw 타입 컬렉션에는 아무 원소나 넣을 수 있으니 타입 불변식을 훼손하기 쉽다.
반면 Collection<?>에는 (null외에는) 어떤 원소도 넣을 수 없다.


raw 타입을 쓰지 말라는 규칙의 예외
- class 리터럴에는 raw 타입을 써야 한다.
List.class, String[].class, int.class는 허용하고 List<String>.class와 List<?>.class는 허용하지 않는다.
- instanceof 연산자.
런타임에는 제네릭 타입 정보가 지워지므로 instanceof 연산자는 비한정적 와일드카드 타입 이외의 매개변수화 타입에는 적용할 수 없다.
그리고 raw 타입이든 비한정적 와일드카드타입이는 instanceof 는 완전히 똑같이 동작한다.

코드 26-7 raw 타입을 써도 좋은 예 - instanceof 연산자
```
if( o instanceof Set) { //raw 타입
	Set<?> s = (Set<?>) o; // 와일드카드 타입
}
```

## 아이템 27. 비검사 경고를 제거하라

warning을 가능한 모두 제거하고, 경고를 제거할 수 없지만 타입 안전하다고 확신할 수 있다면 @SuppressWarning("unchecked") 애너테이션을 달아 경고를 숨기자.
@SuppressWarning 은 가능한 한 좁은 범위에 적용하고 그 경고를 무시해도 안전한 이유를 항상 주석으로 남겨야 한다.

## 아이템 28. 배열보다는 리스트를 사용하라.
배열과 제네릭 타입에는 중요한 차이가 두가지 있다.

첫번째, 배열은 공변(Sub가 Super의 하위 타입이라면 배열 Sub[]는 배열 Super[]의 하위 타입이 된다. 즉 함께 변한다는 뜻)이다.
반면 제네릭은 불공변이다. 즉 서로 다른 타입 Type1과 Type2가 있을 때, List<Type1>은 List<Type2>의 하위 타입도 아니고 상위 타입도 아니다.

코드 28-1 런타임에 실패한다.
```
Object[] objectArray = new Long[1];
objectArray[0] = "타입이 달라 넣을 수 없다."; //ArrayStoreException을 던진다.
```

하지만 다음 코드는 문법에 맞지 않는다.
코드 28-2 컴파일되지 않는다.
```
List<Object> ol = new ArrayList<Long>(); //호환되지 않는 타입이다.
```

두번째, 배열은 실체화(reify)된다. 배열은 런타임에도 자신이 담기로 한 원소의 타입을 인지하고 확인한다. 
그래서 28-1 코드에서 Long 배열에 String을 넣으려 하면 ArrayStoreException이 발생한다. 
반면 제네릭은 타입 정보가 런타임에는 소거(erasure)된다. 원소 타입을 컴파일타임에만 검사하며 런타임에는 알수조차 없다는 뜻이다.


정리.
배열과 제네릭에는 매우 다른 타입 규칙이 적용된다. 배열은 공변이고 실체화되는 반면, 제네릭은 불공변이고 타입 정보가 소거된다. 그 결과 배열은 런타임에는 타입 안전하지만 컴파일타임에는 그렇지 않다.
제네릭은 반대다. 그래서 둘을 섞어 쓰기란 쉽지 않다. 둘을 섞어 쓰다가 컴파일 오류나 경고를 만나면, 가장 먼저 배열을 리스트로 대체하는 방법은 적용해보자.

